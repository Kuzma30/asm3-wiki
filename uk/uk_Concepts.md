# Система координат

Користувачам рекомендується спочатку прочитати [цей посібник](https://web.archive.org/web/20191130140733/https://www.freecadweb.org/wiki/Assembly_Basic_Tutorial), щоб отримати деяку інформацію про нову концепцію _локальної системи координат_. Цей підручник призначений для оригінального робочого середовища Assembly (незавершеного), але він також дає вичерпний огляд того, що також надає Assembly3. `Part` або контейнер `Product` зазначений в посібнику, еквівалентний контейнеру `Assembly` в Assembly3, яку, звісно, ​​можна розглядати як _частину_ і додавати до інших збірок. Є одна річ, з якою я не погоджуюсь у цьому посібнику. Концепція _глобальної системи координат_ все ще є корисною та необхідною для взаємодії з об’єктами з інших застарілих робочих середовищ. Давайте просто визначимо _глобальну систему координат_ як систему координат 3D-виду, іншими словами, місце, де ви насправді бачите об’єкт у 3D-виді, або координати, які показують в рядку стану під час наведенні курсора миші на якийсь об’єкт.

У upstream FreeCAD існує контейнер `App::Part`, який є об’єктом групового типу, який визначає локальну систему координат. Різниця в порівнянні з контейнером Assembly3 полягає в тому, що один об’єкт можна додати до одного і лише одного контейнера `App::Part`. Контейнер власника можна додати до іншого контейнера `App::Part`, але він має підкорятися правилу одного безпосереднього батьківського контейнера. Причина цього полягає в тому, що коли будь-який об’єкт додається до `App::Part`, він фізично видаляється з початкової батьківської системи координат і додається до системи координат `App::Part` власника, тому об'єкт не може з'являтися більше ніж в одній системі координат. Під _фізичним видаленням_ я маю на увазі, що дані тривимірного візуального представлення фізично переміщуються в іншу систему координат всередині графу 3D сцени (докладніше дивіться [тут](https://www.freecadweb.org/wiki/Scenegraph)).

У Assembly3 контейнері немає такого обмеження. При додаванні до контейнера Assembly3 візуальні дані об’єкта просто повторно використовуються і вставляються кілька разів у граф сцени, що означає, що об’єкт фактично існує одночасно в кількох системах координат. Це має дещо несподіваний побічний ефект. Коли об’єкт додається до збірки з певним розташуванням, об’єкт, здавалося б, стрибає на нове місце (Оновлення: з’явилася нова функція автоматичного налаштування розташування під час перекидання об’єкта в іншу систему координат. Щоб активувати його, клацніть правою кнопкою миші в будь-якому місці ієрархії документа та виберіть `Tree options -> Sync placement`). Це очікувано, оскільки об’єкт входить у нову систему координат, і, схоже, він має таку ж поведінку, як `App::Part`. Але насправді сталося те, що початковий об’єкт всередині глобальної системи координат просто робиться невидимим перед додаванням до контейнера збірки. Ви можете перевірити це, переключивши властивість `Visibility` вручну, щоб побачити об’єкт у його початковому розташуванні. Властивість кожного об’єкта `Visibility` контролює його власну видимість лише в глобальній системі координат. Кожен контейнер збірки має властивість `VisibilityList`, щоб контролювати видимість своїх дітей.

# Link (Посилання)

Ядро відгалуження FreeCAD запровадив новий тип об'єкта, що називається _Link(Посилання)_. Об’єкт типу _Link_ (не плутати з _link property_) часто не має власних даних геометрії, а замість цього має посилання на інші об’єкти (використовуючи властивість посилання) для обміну даними геометрії. Його супровідний постачальник представлення даних, `Gui::View ProviderLink`, посилається на постачальника представлення пов’язаних об’єктів для обміну візуальними даними. Це найефективніший спосіб дублювання одного і того ж об’єкта в різних місцях з додатковим перевизначенням масштабу/відзеркалювання та матеріалу. Ядро забезпечує розширення `App::LinkBase Extension` як гнучкий спосіб допомогти користувачам розширити власний об’єкт в об’єкт типу посилання. У розширенні використовується так званий _шаблон проєктування властивостей_, що означає, що саме розширення не визначає жодної властивості, але має купу попередньо визначених місць для зберігання властивостей.</0>. Розширення активує частину цих функцій в залежності від того, які властивості визначені в об’єкті. Цей шаблон проектування дозволяє об’єкту вибирати власні назви властивостей і типи.

Ядро надає два готові до використання об'єкти типу посилання, `App::Link` і `App::LinkGroup`, які відкривають різні частини `LinkBaseExtension` функціональності. `App::Link` підтримує посилання на об’єкт, у тому самому або зовнішньому документі, і має вбудовану підтримку масивів (через властивість `ElementCount`) для ефективного дублювання об'єктів. `LinkGroup` діє як група об’єктів з локальною системою координат. Він покладається на `LinkBaseExtension` і `ViewProviderLink` для надання розширених функцій, наприклад, додавання зовнішнього дочірнього об’єкта, додавання одного й того ж об’єкта кілька разів тощо. Усі контейнери Assembly3 це фактично налаштовані `LinkGroup`.

# Element (Елемент)

`Element` – це абсолютно нова концепція, представлена ​​Assembly3. Він використовується для мінімізації жахливих наслідків зміни топологічних імен геометрії, а також вносить об'єктноорієнтовану концепцію в світ CAD збірок. `Елемент` можна розглядати як декларацію інтерфейсу підключення базової збірки, щоб інша батьківська збірка могла знати, яку частину цієї збірки можна об’єднати з іншими.

Для системи на основі геометричних обмежень, кожне обмеження визначає певний зв’язок між елементами геометрії певних об’єктів. Умовно обмеження посилається на ці елементи геометрії за їх топологічними іменами, наприклад `Fusion001.Face1`, `Cut002.Edge2` тощо. Проблема цього простого підходу полягає в тому, що топологічні назви непостійні. Площини або ребра можуть бути додані/видалені після зміни геометричної моделі. Можна застосувати більш складний алгоритм, щоб зменшити зміну топологічної назви, але ніколи не буде гарантії фіксованих топологічних імен. Уявіть собі простий, але екстремальний випадок, коли користувач просто хоче замінити всю дочірню функцію, скажімо, змінити тип якогось гвинта. Ці дві функції є абсолютно різними об’єктами геометрії з різними топологічними іменами. Користувач повинен вручну знаходити та змінювати посилання геометрії на оригінальний дочірній елемент в багатьох обмеженнях, які можуть існувати в кількох ієрархіях збірок, у декількох документах.

Рішення, представлене Assembly3, полягає у використанні абстракції шляхом додавання кількох рівнів напрямків до посилань геометрії. Кожен контейнер `Збірки` має групу елементів, яка містить список `Елементів`, які є посиланням на об’єкт, який зв’язується з деяким елементом геометрії певної дочірньої функції цієї збірки. Якщо функція також є `Збіркою`, то `Елемент` у верхній ієрархії вказуватиме на `Елемент` всередині збірки нижньої ієрархії. Таким чином, кожен `Елемент` діє як абстракція, з якою елемент геометрії може використовувати інші батьківські збірки. Будь-яке обмеження, що включає деяку збірку, буде лише опосередковано посилатися на елемент геометрії через `Елемент` певної дочірньої збірки. Якщо топологічна назва елемента геометрії змінюється з будь-якої причини, користувачеві потрібно змінити лише найглибше вкладене (тобто найближче до фактичного геометричного об’єкта) посилання `Елементу`. При цьому вся ієрархія повязаних ` Елементів` та відповідні обмеження залишаються незмінними.

`Елемент` – це спеціалізоване `App::Link`, який зв’язується з підоб’єктом, використовуючи `PropertyXLink`, яке приймає `tuple(object, subname)` посилання. Крім того, `Елемент` дозволяє зв'язуватись за його міткою, а не за незмінним внутрішнім ім’ям об’єкта FreeCAD. `Елемент` спеціально дозволяє дублювати свою мітку (але все одно забезпечує унікальність серед своїх братів і сестер). Це дає змогу користувачеві визначати взаємозамінні частини з однаковим набором елементів як інтерфейс.

Давайте наприклад, подивимося на наступну ієрархію збірки,

```
Assembly001
    |--Constraints001
    |       |--Constraint001
    |               |--ElementLink -> (Elements001, "$Element.")
    |               |--ElementLink001 -> (Parts001, "Assembly002.Elements002.$Element001.")
    |--Elements001
    |     |--Element -> (Parts001, "Cut.Face3")
    |--Parts001
          |--Cut
          |--Assembly002
                 |--Constraints002
                 |--Elements002
                 |      |--Element001 -> (Parts002, "Assembly003.Elements003.$Element002.")
                 |--Parts002
                       |--Assembly003
                                |--Constraints003
                                |--Elements003
                                |       |--Element002 -> (Parts003, "Fusion.Face1")
                                |--Parts003
                                       |--Fusion
```

`Assembly001` має дві дочірні функції, об’єкт `Cut` і дочірній об’єкт `Assembly002`, який, у свою чергу, має власну дочірню функцію `Assembly003</0 >. <code>Assembly001` містить обмеження `Constraint001`, яке визначає зв’язок двох його дочірніх функцій. `Constraint001` відноситься до двох елементів геометрії через два посилання, `ElementLink`, які вказують на посилання другого рівня, `Element`. `ElementLink001` вказує на `Element001`, і оскільки перша дочірня функція `Cut` не визначена як збірка, її посилання на елемент геометрії безпосередньо зберігається всередині групи елементів батьківської збірки. Однак `Element001` посилається на нижчу ієрархію `Element002` у своїй дочірній збірці, яка знову посилається на `Element003` у своїй дочірній збірці `Assembly003`. Зверніть увагу на `$` в іменах всередині посилань. Дане позначення буде міткою, а не символом з назвою об'єкта. Якщо ви повторно перейменували об’єкт, всі `PropertyXLink` з усіх відкритих документах, що містять посилання на цю мітку, буде автоматично оновлено.

Головна ідея полягає в тому, що після того, як автор змінив збірку, будь то модифікація геометрічної моделі, або заміна якоїсь дочірньої функції, йому потрібно перевірити всі посилання на елементи всередині тільки цієї збірки та скоректувати необхідні налаштування, щоб виправити будь-які небажані зміни. Інші збірки з елементами або обмеженнями, які посилаються на цю збірку, залишаться незмінними (хоча переобчислення все одно потрібне), навіть якщо ці збірки містяться в різних документах або створені різними авторами.

Скажімо, ми змінили `Fusion`, і оригінал `Fusion.Face1` тепер змінено на `Face10`. Все, що нам потрібно зробити, це просто змінити `Element002` всередині тієї самої збірки власника `Fusion`. Все інше залишається таким самим.

Наприклад, далі ми хочемо замінити `Assembly003` на іншу збірку. Тепер це трохи проблематично (?), тому що ми додали `Aseembly003` безпосередньо до `Assembly002`, замість того, щоб використовувати посилання, яке можна динамічно змінювати. Ядро FreeCAD має загальну команду для спрощення цього завдання. Клацніть правою кнопкою на `Assembly003` в ієрархії документу, виберіть `Link actions -> Replace with link`. `Assembly003` всередині `Parts002` тепер буде замінено посиланням на `Assembly003`. Кожне залежне посилання, яке включає `Parts002.Assembly003`, буде автоматично оновлено на `Parts002.Link_Assembly003`. У нашому випадку це буде `Element001`. Потім ви можете просто змінити посилання, щоб воно вказувало на іншу збірку, що містить об’єкт елемента з такою ж міткою `Element001` (запам’ятайте, що об’єкт елемента дозволяє дублювати мітки). Якщо вам необхідно безпосередньо додати нову збірку і позбутися посилання, ви можете використати `Link actions -> unlink`, а потім видалити об’єкт посилання.

Може здатися страхітливим підтримувати всі ці складні ієрархії `елементів`, але правда полягає в тому, що користувачу взагалі не обов’язково створювати будь-який елемент вручну. Просто виберіть будь-які два елементи геометрії в 3D виді, і ви зможете створити обмеження, незалежно від того, скільки рівнів ієрархії між ними. Усі проміжні `елементи` та `посилання на елементи` будуть створені автоматично. Хоча з метою повторного використання користувачеві як автору збірки найкраще явно створити `Елементи` як інтерфейс, та дати їм власні імена для подальшого збирання. Прогляньте [[цей|Replacing-Part]] навчальний курс для демонстрації заміни деталей.

І останнє, але не менш важливе, `Element`, а також `ElementLink` всередині обмеження, використовують нову функцію `OnTopWhenSelected`, щоб примусово показувати залежні елементи геометрії (площина, ребро, вершина) при виділені, незалежно від інших заважаючих об’єктів. Властивість `OnTopWhenSelected` доступна для всіх об’єктів перегляду, але за замовчуванням має значення `False`, тоді як використання `Element` та `ElementLink` робить її активною за замовчуванням. Ця функція робить ще простішою для користувача перевірку будь-якої аномалії через зміну топологічної назви.

# Виділення

У FreeCAD є два типи виділення: вибір елемента геометрії клацанням у 3D виді та виділення всього об’єкта клацанням в ієрархії документа. При використанні Assembly3 важливо розрізняти ці два типи виділення, тому що зараз є багато об’єктів лише з одним елементом геометрії. Поки ви звикнете до них, корисно відкрити вікно вибору (рядок меню FreeCAD, `View -> Panels -> Selection view`). Ви можете виділити елемент геометрії, клацнувши будь-який невиділений елемент (площина, ребро або вершина) у 3D виді. Якщо клацнути на вже виділеному елементі, виділення підніметься на одну ієрархію вище. Наприклад, для `LinkGroup`, показаної нижче,

```
LinkGroup
    |--LinkGroup001
    |       |--Fusion
    |       |--Cut
    |--Cut001 
```

Припустимо, ви вже вибрали `Fusion.Face1`. Якщо ви знову клацнете на цю поверхню, виділення підніметься на одну ієрархію вгору та виділиться весь об’єкт `Fusion`. Якщо ви знову клацнете в будь-якому місці всередині об’єкта `Fusion`, виділення перейде до `LinkGroup001`, і ви побачите `Fusion` і `Cut` виділеними. Якщо ви знову клацнете де-небудь всередині `LinkGroup001`, `Cut001` також буде виділено, оскільки вибрано всю `LinkGroup`. Клацніть ще раз у `LinkGroup`, вибір повернеться до елемента геометрії, який ви щойно клацнули.

З’явилася нова функція для показу виділення у форці FreeCAD. Встановіть прапорець `Enable pick list` у вікні вибору. Тепер ви можете обрати будь-яку накладений елемент геометрії, яка перетинаються з клацом миші на показі виділення.

Можливо, вам буде корисно ввімкнути синхронізацію вибору з ієрархією документа (клацніть правою кнопкою миші в ієрархії, виберіть `Синхронізувати виділення`), щоб дерево автоматично прокручувалося до об’єкта, який ви щойно вибрали в 3D виді. Коли ви вибираєте попередньо не вибраний об’єкт в ієрархії, весь об’єкт бути виділеним. І якщо ви почнете перетягувати елемент об’єкта в ієрархії документа, ви перетягнете весь об’єкт. Якщо ви виберете елемент геометрії в 3D виді, його власник також буде виділено в ієрархії. Але якщо ви потім ініціюєте перетягування цього конкретного об’єкта, ви фактично перетягуєте вибраний елемент геометрії. Це важлива відмінність, тому що деякі контейнери, такі як об’єкт `Constraint`, дозволяють перетягнути лише елементи геометрії та відмовляються від всього об’єкта.

* 2D/3D Ескіз

Використання ескізу в збірці — це техніка, яка називається _Моделювання скелета_. Це тип підходу до проектування зверху вниз, коли ви малюєте ескізи каркаса (лінії, дуги тощо), щоб визначити критерії проектування, а потім додаєте окремі компоненти, які посилаються на ці критерії. Деякі типи механічних систем природно моделюються в 2D, наприклад. штирькове з’єднання, яке може обертатися лише в площині, тоді як інші необхідно моделювати в 3D, напр. кульовий шарнір.

FreeCAD вже має потужне робоче середовище _Sketcher_, але він обмежений створенням 2D-ескізів. Крім того, ескіз більше орієнтований на моделювання геометрії, тобто створення основ для видавлення, заглиблення тощо. Об’єкт ескізу зберігає всі елементи та обмеження всередині самого об’єкта. Він має власний редактор і вирішувач, що робить його найскладнішим окремим об’єктом у всьому FreeCAD. Замість того, щоб модифікувати об’єкт ескізу, щоб він відповідав потребам збірки, Assembly3 вирішив залишити призначення деяких об’єктів із робочого середовища _Draft_ без змін. Я вважаю, що робоче середовище Draft спочатку використовувалось для створення ескізів до народження більш спеціалізованого редактора.

На момент написання цієї статті Assembly3 підтримує використання линій та кіл/дуг для створення ескізів. Для звичайних об’єктів, доданих до контейнера збірки як деталі, розміщення об’єкта використовується як обмежувальні параметри (див. [[тут|Constraints-and-Solvers]] для більш детальної інформації). Лінії з Draft обробляються особливо. Замість того, щоб обмежувати розміщення об’єкта, вони обмежують координатами кожної окремої точки. Як і інші об’єкти, коло draft все ще обмежене щодо свого розташування, але з додатковими параметрами радіуса та дуги, двома параметрами для першого та останнього кутів, які визначають дві його кінцеві точки. Лінія Draft має багато варіантів використання, не всі з яких прийнятні через обмеження ескізу (наприклад, `LineLength`). Допускаються тільки нерозділені лінії без базового об'єкта або об'єкту інструменту.

Додані draft об'єкти можуть вільно рухатись в 3D-просторі. Щоб створити 2D-ескіз, ви можете додати обмеження `SketchPlane`. Як перший елемент для площини ескізу воно приймає будь-яке ребро або площину. Будь-які елементи об’єкта draft, що мають відношення до наступних обмежень, будуть неявно обмежені цією площиною. Ви також можете явно додати елементи в обмеження `SketchPlane`. Щоб скинути поточну площину ескізу, тобто зробити наступні елементи чернетки вільними в 3D, додайте порожнє обмеження `SketchPlane`. Ви можете визначити більше одної площини ескізу в одному контейнері збірки.

Ви можете переглянути [[цей|Create-Skeleton-Sketch]] посібник, щоб дізнатися більше


